// Code generated by protoc-gen-go. DO NOT EDIT.
// source: sentence.proto

package sentencepb

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// A request to split a sentence into individual words
type SplitSentenceRequest struct {
	// The sentence to split
	Sentence             string   `protobuf:"bytes,1,opt,name=sentence,proto3" json:"sentence,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SplitSentenceRequest) Reset()         { *m = SplitSentenceRequest{} }
func (m *SplitSentenceRequest) String() string { return proto.CompactTextString(m) }
func (*SplitSentenceRequest) ProtoMessage()    {}
func (*SplitSentenceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_90acaebd5436658e, []int{0}
}

func (m *SplitSentenceRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SplitSentenceRequest.Unmarshal(m, b)
}
func (m *SplitSentenceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SplitSentenceRequest.Marshal(b, m, deterministic)
}
func (m *SplitSentenceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SplitSentenceRequest.Merge(m, src)
}
func (m *SplitSentenceRequest) XXX_Size() int {
	return xxx_messageInfo_SplitSentenceRequest.Size(m)
}
func (m *SplitSentenceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SplitSentenceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SplitSentenceRequest proto.InternalMessageInfo

func (m *SplitSentenceRequest) GetSentence() string {
	if m != nil {
		return m.Sentence
	}
	return ""
}

// A unary response for splitting a sentence
type SplitSentenceUnaryResponse struct {
	// The individual words in the sentence
	Words                []string `protobuf:"bytes,1,rep,name=words,proto3" json:"words,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SplitSentenceUnaryResponse) Reset()         { *m = SplitSentenceUnaryResponse{} }
func (m *SplitSentenceUnaryResponse) String() string { return proto.CompactTextString(m) }
func (*SplitSentenceUnaryResponse) ProtoMessage()    {}
func (*SplitSentenceUnaryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_90acaebd5436658e, []int{1}
}

func (m *SplitSentenceUnaryResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SplitSentenceUnaryResponse.Unmarshal(m, b)
}
func (m *SplitSentenceUnaryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SplitSentenceUnaryResponse.Marshal(b, m, deterministic)
}
func (m *SplitSentenceUnaryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SplitSentenceUnaryResponse.Merge(m, src)
}
func (m *SplitSentenceUnaryResponse) XXX_Size() int {
	return xxx_messageInfo_SplitSentenceUnaryResponse.Size(m)
}
func (m *SplitSentenceUnaryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SplitSentenceUnaryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SplitSentenceUnaryResponse proto.InternalMessageInfo

func (m *SplitSentenceUnaryResponse) GetWords() []string {
	if m != nil {
		return m.Words
	}
	return nil
}

// A stream response for splitting a sentence
type SplitSentenceStreamResponse struct {
	// A single word from the sentence in the request
	Word                 string   `protobuf:"bytes,1,opt,name=word,proto3" json:"word,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SplitSentenceStreamResponse) Reset()         { *m = SplitSentenceStreamResponse{} }
func (m *SplitSentenceStreamResponse) String() string { return proto.CompactTextString(m) }
func (*SplitSentenceStreamResponse) ProtoMessage()    {}
func (*SplitSentenceStreamResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_90acaebd5436658e, []int{2}
}

func (m *SplitSentenceStreamResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SplitSentenceStreamResponse.Unmarshal(m, b)
}
func (m *SplitSentenceStreamResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SplitSentenceStreamResponse.Marshal(b, m, deterministic)
}
func (m *SplitSentenceStreamResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SplitSentenceStreamResponse.Merge(m, src)
}
func (m *SplitSentenceStreamResponse) XXX_Size() int {
	return xxx_messageInfo_SplitSentenceStreamResponse.Size(m)
}
func (m *SplitSentenceStreamResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SplitSentenceStreamResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SplitSentenceStreamResponse proto.InternalMessageInfo

func (m *SplitSentenceStreamResponse) GetWord() string {
	if m != nil {
		return m.Word
	}
	return ""
}

func init() {
	proto.RegisterType((*SplitSentenceRequest)(nil), "covr.grpc.sentence.SplitSentenceRequest")
	proto.RegisterType((*SplitSentenceUnaryResponse)(nil), "covr.grpc.sentence.SplitSentenceUnaryResponse")
	proto.RegisterType((*SplitSentenceStreamResponse)(nil), "covr.grpc.sentence.SplitSentenceStreamResponse")
}

func init() { proto.RegisterFile("sentence.proto", fileDescriptor_90acaebd5436658e) }

var fileDescriptor_90acaebd5436658e = []byte{
	// 212 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0xe2, 0x2b, 0x4e, 0xcd, 0x2b,
	0x49, 0xcd, 0x4b, 0x4e, 0xd5, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x12, 0x4a, 0xce, 0x2f, 0x2b,
	0xd2, 0x4b, 0x2f, 0x2a, 0x48, 0xd6, 0x83, 0xc9, 0x28, 0x19, 0x71, 0x89, 0x04, 0x17, 0xe4, 0x64,
	0x96, 0x04, 0x43, 0x05, 0x82, 0x52, 0x0b, 0x4b, 0x53, 0x8b, 0x4b, 0x84, 0xa4, 0xb8, 0x38, 0x60,
	0x6a, 0x24, 0x18, 0x15, 0x18, 0x35, 0x38, 0x83, 0x38, 0x90, 0xf4, 0x48, 0xa1, 0xe8, 0x09, 0xcd,
	0x4b, 0x2c, 0xaa, 0x0c, 0x4a, 0x2d, 0x2e, 0xc8, 0xcf, 0x2b, 0x4e, 0x15, 0x12, 0xe1, 0x62, 0x2d,
	0xcf, 0x2f, 0x4a, 0x29, 0x96, 0x60, 0x54, 0x60, 0xd6, 0xe0, 0x0c, 0x82, 0x70, 0x94, 0x0c, 0xb9,
	0xa4, 0x51, 0xf4, 0x04, 0x97, 0x14, 0xa5, 0x26, 0xe6, 0xc2, 0x35, 0x09, 0x71, 0xb1, 0x80, 0xd4,
	0x41, 0xad, 0x02, 0xb3, 0x8d, 0x1e, 0x31, 0x72, 0x71, 0xc0, 0x94, 0x0b, 0x65, 0x70, 0x71, 0x81,
	0xf5, 0x83, 0xed, 0x12, 0xd2, 0xd0, 0xc3, 0xf4, 0x8a, 0x1e, 0x36, 0x7f, 0x48, 0xe9, 0x11, 0x54,
	0x89, 0xe2, 0x7a, 0x25, 0x06, 0xa1, 0x1c, 0x2e, 0x6e, 0x88, 0x3c, 0xd8, 0x85, 0x24, 0x58, 0xa5,
	0x4f, 0x50, 0x25, 0xaa, 0xa7, 0x95, 0x18, 0x0c, 0x18, 0x9d, 0x78, 0xa2, 0xb8, 0x60, 0x6a, 0x0b,
	0x92, 0x92, 0xd8, 0xc0, 0x11, 0x65, 0x0c, 0x08, 0x00, 0x00, 0xff, 0xff, 0x6c, 0xa3, 0x96, 0xf8,
	0xba, 0x01, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// SentenceClient is the client API for Sentence service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SentenceClient interface {
	// Split the sentence and get a single response with all of the words in it
	SplitUnary(ctx context.Context, in *SplitSentenceRequest, opts ...grpc.CallOption) (*SplitSentenceUnaryResponse, error)
	// Split the sentence and get a response for each word that was in the sentence
	SplitStream(ctx context.Context, in *SplitSentenceRequest, opts ...grpc.CallOption) (Sentence_SplitStreamClient, error)
}

type sentenceClient struct {
	cc *grpc.ClientConn
}

func NewSentenceClient(cc *grpc.ClientConn) SentenceClient {
	return &sentenceClient{cc}
}

func (c *sentenceClient) SplitUnary(ctx context.Context, in *SplitSentenceRequest, opts ...grpc.CallOption) (*SplitSentenceUnaryResponse, error) {
	out := new(SplitSentenceUnaryResponse)
	err := c.cc.Invoke(ctx, "/covr.grpc.sentence.Sentence/SplitUnary", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sentenceClient) SplitStream(ctx context.Context, in *SplitSentenceRequest, opts ...grpc.CallOption) (Sentence_SplitStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Sentence_serviceDesc.Streams[0], "/covr.grpc.sentence.Sentence/SplitStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &sentenceSplitStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Sentence_SplitStreamClient interface {
	Recv() (*SplitSentenceStreamResponse, error)
	grpc.ClientStream
}

type sentenceSplitStreamClient struct {
	grpc.ClientStream
}

func (x *sentenceSplitStreamClient) Recv() (*SplitSentenceStreamResponse, error) {
	m := new(SplitSentenceStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// SentenceServer is the server API for Sentence service.
type SentenceServer interface {
	// Split the sentence and get a single response with all of the words in it
	SplitUnary(context.Context, *SplitSentenceRequest) (*SplitSentenceUnaryResponse, error)
	// Split the sentence and get a response for each word that was in the sentence
	SplitStream(*SplitSentenceRequest, Sentence_SplitStreamServer) error
}

// UnimplementedSentenceServer can be embedded to have forward compatible implementations.
type UnimplementedSentenceServer struct {
}

func (*UnimplementedSentenceServer) SplitUnary(ctx context.Context, req *SplitSentenceRequest) (*SplitSentenceUnaryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SplitUnary not implemented")
}
func (*UnimplementedSentenceServer) SplitStream(req *SplitSentenceRequest, srv Sentence_SplitStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method SplitStream not implemented")
}

func RegisterSentenceServer(s *grpc.Server, srv SentenceServer) {
	s.RegisterService(&_Sentence_serviceDesc, srv)
}

func _Sentence_SplitUnary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SplitSentenceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SentenceServer).SplitUnary(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/covr.grpc.sentence.Sentence/SplitUnary",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SentenceServer).SplitUnary(ctx, req.(*SplitSentenceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Sentence_SplitStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SplitSentenceRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SentenceServer).SplitStream(m, &sentenceSplitStreamServer{stream})
}

type Sentence_SplitStreamServer interface {
	Send(*SplitSentenceStreamResponse) error
	grpc.ServerStream
}

type sentenceSplitStreamServer struct {
	grpc.ServerStream
}

func (x *sentenceSplitStreamServer) Send(m *SplitSentenceStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _Sentence_serviceDesc = grpc.ServiceDesc{
	ServiceName: "covr.grpc.sentence.Sentence",
	HandlerType: (*SentenceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SplitUnary",
			Handler:    _Sentence_SplitUnary_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SplitStream",
			Handler:       _Sentence_SplitStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "sentence.proto",
}
